# -*- coding: utf-8 -*-
"""Solución por métodos numéricos de la Geodésica.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/10uhmRMfq8-M-2t5OcumbjU3iT3cskFcs
"""

import matplotlib.pyplot as plt
from mpl_toolkits import mplot3d
import mpmath as mp
import numpy as np
from sympy import *
from sympy.core.rules import Transform

def sphere(r):
    u = np.linspace(0, 2 * np.pi, 1000)
    v = np.linspace(0, np.pi, 1000)
    d = (r) * np.outer(np.cos(u), np.sin(v))
    e = (r) * np.outer(np.sin(u), np.sin(v))
    g = (r) * np.outer(np.ones(np.size(u)), np.cos(v))
    return d,e,g

"""## Método de Euler Esfera"""

n=1000
h=2*np.pi/(n-1)
x = np.zeros(n)
y = np.zeros(n)
thetaE = np.zeros(n)
phiE = np.zeros(n)
x[0]=-1/np.sqrt(2) #derivada en theta asumiendo S_0=0
y[0]=1/np.sqrt(2) #derivada en phi asumiendo S_0=0
thetaE[0]=np.pi/2
phiE[0]=0

for i in np.arange(1,n):
    thetaE[i]=thetaE[i-1]+(x[i-1])*h
    phiE[i]=phiE[i-1]+(y[i-1])*h
    x[i]=x[i-1]+(mp.sin(thetaE[i-1])*mp.cos(thetaE[i-1])*(y[i-1])**2)*h
    y[i]=y[i-1]-(2*(mp.cot(thetaE[i-1]))*x[i-1]*y[i-1])*h

s=np.linspace(0,2*np.pi,n)
plt.plot(s,thetaE,label="theta")
plt.plot(s,phiE,label="phi")
plt.xlabel('ds')
plt.ylabel('Soluciones')
plt.legend()
plt.show()

X = np.zeros(n)
Y = np.zeros(n)
Z = np.zeros(n)
for i in np.arange(n):
  X[i]= np.cos(phiE[i])*np.sin(thetaE[i])
  Y[i]= np.sin(phiE[i])*np.sin(thetaE[i])
  Z[i]= np.cos(thetaE[i])
fig=plt.figure(figsize=(10,6))
ax = plt.axes(projection='3d')
ax.plot3D(X, Y, Z,'blue')
d,e,g = sphere(1)
ax = fig.gca(projection='3d')
ax.plot_surface(d, e, g, rstride=3, cstride=3, color=(1,0.8,0,0.1))
ax.set_xlabel('Eje X')
ax.set_ylabel('Eje Y')
ax.set_zlabel('Eje Z')
plt.title('Solución numérica de la Geodésica por el método de Euler para la Esfera')
plt.show()

"""## Método de Runge-Kutta Esfera"""

n=1000
h=2*np.pi/(n-1)
x = np.zeros(n)
y = np.zeros(n)
theta = np.zeros(n)
phi = np.zeros(n)
t=np.zeros(n)
x[0]=-1/np.sqrt(2) #derivada en theta asumiendo S_0=0
y[0]=1/np.sqrt(2) #derivada en phi asumiendo S_0=0
theta[0]=np.pi/2
phi[0]=0

def f1 (x,y,theta):
    return (mp.sin(theta)*mp.cos(theta)*y**2)

def f2 (x,y,theta):
    return -2*(mp.cot(theta))*x*y

def f3 (x):
    return x

def f4 (y):
    return y


for i in np.arange(1,n):
    t[i]=t[i-1]+h
    k1t=f3(x[i-1])
    k2t=f3((x[i-1]+(k1t*h)/2))
    k3t=f3((x[i-1]+(k2t*h)/2))
    k4t=f3((x[i-1]+(k3t*h)))
    theta[i]=theta[i-1]+((h/6)*(k1t+2*(k2t+k3t)+k4t))

    k1p=f4(y[i-1])
    k2p=f4((y[i-1]+(k1p*h)/2))
    k3p=f4((y[i-1]+(k2p*h)/2))
    k4p=f4((y[i-1]+(k3p*h)))
    phi[i]=phi[i-1]+((h/6)*(k1p+2*(k2p+k3p)+k4p))

    k1f1=f1(x[i-1],y[i-1],theta[i-1])
    k1f2=f2(x[i-1],y[i-1],theta[i-1])
    k2f1=f1(x[i-1]+(k1t*h)/2,y[i-1]+((h*k1f1)/2),theta[i-1]+((h*k1f2)/2))
    k2f2=f2(x[i-1]+(k1t*h)/2,y[i-1]+((h*k1f1)/2),theta[i-1]+((h*k1f2)/2))
    k3f1=f1(x[i-1]+(k2t*h)/2,y[i-1]+((h*k2f1)/2),theta[i-1]+((h*k2f2)/2))
    k3f2=f2(x[i-1]+(k2t*h)/2,y[i-1]+((h*k2f1)/2),theta[i-1]+((h*k2f2)/2))
    k4f1=f1(x[i-1]+(k3t*h),y[i-1]+(h*k3f1),theta[i-1]+(h*k3f2))
    k4f2=f2(x[i-1]+(k3t*h),y[i-1]+(h*k3f1),theta[i-1]+(h*k3f2))

    x[i]=x[i-1]+((h/6)*(k1f1+2*(k2f1+k3f1)+k4f1))
    y[i]=y[i-1]+((h/6)*(k1f2+2*(k2f2+k3f2)+k4f2))

s=np.linspace(0,2*np.pi,n)
plt.plot(t,theta,label="theta")
plt.plot(t,phi,label="phi")
plt.xlabel('ds')
plt.ylabel('Soluciones')
plt.legend()
plt.show()

X1 = np.zeros(n)
Y1 = np.zeros(n)
Z1 = np.zeros(n)
for i in np.arange(n):
  X1[i]= np.sin(theta[i])*np.cos(phi[i])
  Y1[i]= np.sin(theta[i])*np.sin(phi[i])
  Z1[i]= np.cos(theta[i])
fig=plt.figure(figsize=(10,6))
ax = plt.axes(projection='3d')
ax.plot3D(X1, Y1, Z1,'blue')
d,e,g = sphere(1)
ax = fig.gca(projection='3d')
ax.plot_surface(d, e, g, rstride=3, cstride=3, color=(1,0.8,0,0.1))
ax.set_xlabel('Eje X')
ax.set_ylabel('Eje Y')
ax.set_zlabel('Eje Z')
plt.title('Solución numérica de la Geodésica por el método de Runge Kutta para la Esfera')
plt.show()

"""## Método de Diferencias Finitas Esfera

Implemente el método de diferencias finitas para resolver la ecuación diferencial

$$ \frac{d^{2} \theta}{ds^{2}}=\sin{(\theta)}\cos{(\theta)} \left(\frac{d \phi}{ds} \right)^{2} \quad (1)$$

$$ \frac{d^{2} \phi}{ds^{2}}=-2\cot{(\theta)} \left(\frac{d \theta}{ds}\right) \left(\frac{d \phi}{ds}\right)  \quad (2)$$

donde
$$\theta(0)=\frac{\pi}{2}, \phi(0)=0 $$
$$\frac{d \theta}{ds}(0)=-\frac{1}{\sqrt{2}}, \frac{d \phi}{ds}(0)=\frac{1}{\sqrt{2}} $$
en el intervalo $0< s < 2 \pi $. Grafique la solución.

Sí

$$ \frac{d \theta}{ds}=x, \quad \frac{d \phi}{ds}=y$$

implica que

$$ \frac{dx}{ds}=y^{2}\sin{(\theta)}\cos{(\theta)}, \quad \frac{dy}{ds}=-2xy\cot{(\theta)}$$

donde
$$\theta(0)=\frac{\pi}{2}, \quad \phi(0)=0 $$
$$x(0)=-\frac{1}{\sqrt{2}},\quad y(0)=\frac{1}{\sqrt{2}} $$

De esta forma

$$ \frac{x(t,h)-x(t,0)}{h}=y^{2}\sin{(\theta)}\cos{(\theta)}, \quad x(t,0)=x(t,h)-h(y^{2}\sin{(\theta)}\cos{(\theta)})$$

$$ \frac{y(t,h)-y(t,0)}{h}=-2xy\cot{(\theta)}, \quad y(t,0)=y(t,h)+2hxy\cot{(\theta)}$$
"""

a=0
b=2*np.pi
T=20

col=1002
row=1002
k=0.1
h_t=T/(row-1)
h_x=(b-a)/(col-1)
x=np.linspace(a,b,col)

MT= np.zeros((row,col))   # MT Matriz de Theta
MP= np.zeros((row,col))   # MP Matriz de phi

MT[:,0]=np.pi/2
MT[:,col-1]=-1/sqrt(2)
MP[:,0]=0
MP[:,col-1]=1/sqrt(2)


for j in range(row-1):
  for i in range(1,col-1):
    MT[j+1,i]=MT[j,i]+k*h_t/(h_x**2)*(MT[j,i+1]-2*MT[j,i]+MT[j,i-1])
  #MT[j+1,0]=MT[j+1,1]
  #MT[j+1,-1]=MT[j+1,-2]
  #plt.plot(x,MT[j,:])

#plt.plot(x,MT[row-1,:])
#plt.show()

plt.figure(figsize=(12,4))
plt.subplot(1,3,1)
plt.title('Iteraciones de la solución')
plt.plot(x,y)
for k in range(M):
  y1.append(y[1])
  for n in range(1,N-1):
    y[n]=(y[n-1]+y[n+1]+4*h**2)/2
  plt.plot(x,y)
plt.subplot(1,3,2)
plt.title('Solución y(x)')
plt.plot(x,y)
plt.subplot(1,3,3)
plt.title('Convergencia')
plt.plot(y1)

plt.show()