# -*- coding: utf-8 -*-
"""Símbolos de Christoffel y solución Elipsoide.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1jL2oQm6GbnqN09QtseMkDOG0cAfEZmX3
"""

import matplotlib.pyplot as plt
from mpl_toolkits import mplot3d
import mpmath as mp
import numpy as np
from sympy import *
from sympy.core.rules import Transform

"""## PARAMETRIZACIÓN ELIPSOIDE"""

a, c, t = symbols('a c t') #t=theta

rt=a*c/sqrt(((c**2)*(sin(t))**2+(a**2)*(cos(t))**2)) #[r(t)]
rt

dr= trigsimp(diff(rt,t)) #dr/dt
dr

"""$[r(\theta)]^{2}\cdot \sin^{2}{\theta}$"""

g22=(rt**2)*(sin(t))**2 #componente g22 del tensor métrico
g22

"""$\left[\frac{dr(\theta)}{d\theta}\right]^{2}+[r(\theta)]^{2}$"""

rt2=rt**2
dr2=dr**2

g11=trigsimp(dr2*rt2) #componente g11 del tensor métrico
g11

"""**Simbolo de Christoffel $\Gamma_{11}^{1}$**"""

dpar=trigsimp(g11.diff(t)) #derivada parcial g11 respecto a theta
invg11=trigsimp(1/g11)

cris111=trigsimp(1/2*invg11*dpar)
cris111

"""**Simbolo de Christoffel $\Gamma_{22}^{1}$**"""

dparg2=trigsimp(g22.diff(t))  #derivada parcial g11 respecto a theta
invg11=trigsimp(1/g11)

cris221=trigsimp(1/2*invg11*-dparg2)
cris221

"""**Simbolo de Christoffel $\Gamma_{12}^{2}$**"""

dparg2=trigsimp(g22.diff(t))  #derivada parcial g11 respecto a theta
invg22=trigsimp(1/g22)

cris122=trigsimp(1/2*invg22*dparg2)
cris122

"""**Ecuación Geodésica para la parametrización de la elipsoide**


$ \frac{d^{2}\theta}{ds^{2}}+\Gamma_{11}^{1}\left(\frac{d\theta}{ds}\right)^{2}+\Gamma_{22}^{1}\left(\frac{d\phi}{ds}\right)^{2}=0 $

$ \frac{d^{2}\phi}{ds^{2}}+\Gamma_{12}^{2}\frac{d\theta}{ds}\cdot \frac{d\phi}{ds}=0$
"""

parte1=(((a**4)*(c**4))*((a**2-c**2)**3)*((mp.sin(2*theta))**3))/((a**2*(mp.cos(theta)**2)+c**2*((mp.sin(theta))**2))**5)
parte2=(((a**4)*(c**4))*((a**2-c**2)**3)*(mp.sin(4*theta)))/(2*(a**2*((mp.sin(theta))**2)-a**2-c**2*((mp.sin(theta))**2))**4)

denominador1=(a**4)*(c**4)*((a**2-c**2)**2)*((mp.sin(2*theta))**2)
numerador1=(2*((a**2*((mp.cos(theta))**2)+c**2*((mp.sin(theta))**2))**4))*(parte1+parte2)
def f1 (a,c,x,theta):
  return((numerador1/denominador1)*x**2)

denominador2=c**2*((a**2-c**2)**2)*mp.sin(2*theta)
numerador2=-0.5*(-a**2*mp.cos(2*theta)-a**2+c**2*mp.cos(2*theta)-c**2)**2
def f2 (a,c,y,theta):
  return((numerador2/denominador2)*y**2)

o1=((mp.tan(theta))**2)+c**2
denominador3=(a**2*((mp.sin(theta))**2)-a**2-c**2*((mp.sin(t))**2))**2
numerador3=(0.5*(a**2))*(a**2/o1)*(mp.sin(2*theta))
def f3 (a,c,x,y,theta):
    return ((numerador3/denominador3)*(x*y))

n=50
a=2
b=1
h=2*np.pi/(n-1)
x = np.zeros(n)
y = np.zeros(n)
thetaE = np.zeros(n)
phiE = np.zeros(n)
x[0]=-1/np.sqrt(2) #derivada en theta asumiendo S_0=0
y[0]=1/np.sqrt(2) #derivada en phi asumiendo S_0=0
thetaE[0]=np.pi/2
phiE[0]=0

for i in np.arange(1,n):
  thetaE[i]=thetaE[i-1]+(x[i-1])*h
  phiE[i]=phiE[i-1]+(y[i-1])*h
  x[i]=x[i-1]-((f1(a,b,x[i-1],thetaE[i-1])))*h

n=50
a=2
b=1
h=2*np.pi/(n-1)
x = np.zeros(n)
y = np.zeros(n)
thetaE = np.zeros(n)
phiE = np.zeros(n)
x[0]=-1/np.sqrt(2) #derivada en theta asumiendo S_0=0
y[0]=1/np.sqrt(2) #derivada en phi asumiendo S_0=0
thetaE[0]=np.pi/2
phiE[0]=0

for i in np.arange(1,n):
  thetaE[i]=thetaE[i-1]+(x[i-1])*h
  phiE[i]=phiE[i-1]+(y[i-1])*h
  x[i]=x[i-1]-((f1(a,b,x[i-1],thetaE[i-1]))+(f2(a,b,y[i-1],thetaE[i-1])))*h
  y[i]=y[i-1]-(f3(a,b,x[i-1],y[i-1],thetaE[i-1]))*h

s=np.linspace(0,2*np.pi,n)
plt.plot(s,thetaE,label="theta")
plt.plot(s,phiE,label="phi")
plt.xlabel('ds')
plt.ylabel('Soluciones')
plt.legend()
plt.show()

"""## PARAMETRIZACIÓN DE LA ELIPSOIDE CON LA FUNCIÓN "NORMAL"

$f(\varphi,\theta)=(a\cos{(\varphi)} \sin{(\theta)},a\sin{(\varphi)} \sin{(\theta)}),b \cos{(\theta)})$ para $(\varphi,\theta)\in [0,2 \pi)\times [0, \pi]$ siempre que $0<b<a$

$$ \frac{\partial f}{\partial \varphi}=(-a\sin{(\varphi)} \sin{(\theta)},a\cos{(\varphi)} \sin{(\theta)}), 0)$$  

$$ \frac{\partial f}{\partial \theta}=(a\cos{(\varphi)} \cos{(\theta)},a\sin{(\varphi)} \cos{(\theta)}), -b \sin{(\theta)})$$

El Tensor Métrico Es

$$\mathbb{G}= \begin{equation}
\left(
\begin{matrix}
a^{2}\cos^{2}{(\theta)}+b^{2}\sin^{2}{(\theta)} & 0  \\
0 & a^{2}\sin^{2}{(\theta)} \\
\end{matrix}
\right)
\end{equation}$$
"""

a, b, t, p = symbols('a b t p') #t=theta y p=phi
g22=(a**2)*(sin(t))**2
g11=(a**2)*(cos(t))**2+(b**2)*(sin(t))**2
invg11=trigsimp(1/g11)
invg22=trigsimp(1/g22)

"""**Simbolo de Christoffel $\Gamma_{12}^{1}$** para $x^{1}=\theta, x^{2}=\varphi$"""

dparg12=trigsimp(g11.diff(t))

cris112=trigsimp(1/2*invg11*dparg12)
cris112

"""**Simbolo de Christoffel $\Gamma_{21}^{1}$**"""

dparg21=trigsimp(g11.diff(t))

cris111=trigsimp(1/2*invg11*dparg21)
cris111

"""**Simbolo de Christoffel $\Gamma_{22}^{2}$**"""

dparg222=trigsimp(g22.diff(t))

cris222=trigsimp(1/2*invg22*dparg221)
cris222

"""**Simbolo de Christoffel $\Gamma_{11}^{2}$**"""

dparg112=trigsimp(g22.diff(t))

cris112=trigsimp(1/2*invg22*dparg112)
cris112

def sphere(a,b):
    u = np.linspace(0, 2 * np.pi, 1000)
    v = np.linspace(0, np.pi, 1000)
    d = (a) * np.outer(np.cos(u), np.sin(v))
    e = (a) * np.outer(np.sin(u), np.sin(v))
    g = (b) * np.outer(np.ones(np.size(u)), np.cos(v))
    return d,e,g

"""## Método de Euler"""

n=1000
a=2
b=1/a
h=2.9*np.pi/(n-1)
x = np.zeros(n)
y = np.zeros(n)
thetaE = np.zeros(n)
phiE = np.zeros(n)
x[0]=-1/np.sqrt(2)  #derivada en theta asumiendo S_0=0
y[0]= 1/np.sqrt(2)  #derivada en phi asumiendo S_0=0
thetaE[0]=np.pi/2
phiE[0]=0
for i in np.arange(1,n):
  parte1=(a**2*mp.tan(thetaE[i-1]))/(a**2+b**2*(mp.tan(thetaE[i-1]))**2)
  parte2=((a**2-b**2)*mp.tan(thetaE[i-1]))/(a**2+b**2*(mp.tan(thetaE[i-1]))**2)
  thetaE[i]=thetaE[i-1]+(x[i-1])*h
  phiE[i]=phiE[i-1]+(y[i-1])*h
  x[i]=x[i-1]+(parte1*(y[i-1])**2+parte2*(x[i-1])**2)*h
  y[i]=y[i-1]-(2*(mp.cot(thetaE[i-1]))*x[i-1]*y[i-1])*h

s=np.linspace(0,2*np.pi,n)
plt.plot(s,thetaE,label="theta")
plt.plot(s,phiE,label="phi")
plt.xlabel('ds')
plt.ylabel('Soluciones')
plt.legend()
plt.show()

X = np.zeros(n)
Y = np.zeros(n)
Z = np.zeros(n)
for i in np.arange(n):
  X[i]= a*(np.cos(phiE[i])*np.sin(thetaE[i]))
  Y[i]= a*(np.sin(phiE[i])*np.sin(thetaE[i]))
  Z[i]= b*np.cos(thetaE[i])
fig=plt.figure(figsize=(10,6))
ax = plt.axes(projection='3d')
ax.plot3D(X, Y, Z,'blue')
d,e,g = sphere(a,b)
ax = fig.gca(projection='3d')
ax.plot_surface(d, e, g, rstride=3, cstride=3, color=(1,0.8,0,0.1))
ax.set_xlabel('Eje X')
ax.set_ylabel('Eje Y')
ax.set_zlabel('Eje Z')
plt.title('Solución numérica de la Geodésica por el método de Euler para la Elipsoide')
plt.show()

"""## Método Runge Kutta"""

n=1000
a=2
b=1/a
h=2*np.pi/(n-1)
x = np.zeros(n)
y = np.zeros(n)
theta = np.zeros(n)
phi = np.zeros(n)
t=np.zeros(n)
x[0]=0 #derivada en theta asumiendo S_0=0
y[0]=1 #derivada en phi asumiendo S_0=0
theta[0]=np.pi/2
phi[0]=0

def f1 (x,y,theta):
  parte1=(a**2*mp.tan(theta))/(a**2+b**2*(mp.tan(theta))**2)
  parte2=((a**2-b**2)*mp.tan(theta))/(a**2+b**2*(mp.tan(theta))**2)
  return (parte1*y**2+parte2*x**2)

def f2 (x,y,theta):
    return -2*(mp.cot(theta))*x*y

def f3 (x):
    return x

def f4 (y):
    return y


for i in np.arange(1,n):
    t[i]=t[i-1]+h
    k1t=f3(x[i-1])
    k2t=f3((x[i-1]+(k1t*h)/2))
    k3t=f3((x[i-1]+(k2t*h)/2))
    k4t=f3((x[i-1]+(k3t*h)))
    theta[i]=theta[i-1]+((h/6)*(k1t+2*(k2t+k3t)+k4t))

    k1p=f4(y[i-1])
    k2p=f4((y[i-1]+(k1p*h)/2))
    k3p=f4((y[i-1]+(k2p*h)/2))
    k4p=f4((y[i-1]+(k3p*h)))
    phi[i]=phi[i-1]+((h/6)*(k1p+2*(k2p+k3p)+k4p))

    k1f1=f1(x[i-1],y[i-1],theta[i-1])
    k1f2=f2(x[i-1],y[i-1],theta[i-1])
    k2f1=f1(x[i-1]+(k1t*h)/2,y[i-1]+((h*k1f1)/2),theta[i-1]+((h*k1f2)/2))
    k2f2=f2(x[i-1]+(k1t*h)/2,y[i-1]+((h*k1f1)/2),theta[i-1]+((h*k1f2)/2))
    k3f1=f1(x[i-1]+(k2t*h)/2,y[i-1]+((h*k2f1)/2),theta[i-1]+((h*k2f2)/2))
    k3f2=f2(x[i-1]+(k2t*h)/2,y[i-1]+((h*k2f1)/2),theta[i-1]+((h*k2f2)/2))
    k4f1=f1(x[i-1]+(k3t*h),y[i-1]+(h*k3f1),theta[i-1]+(h*k3f2))
    k4f2=f2(x[i-1]+(k3t*h),y[i-1]+(h*k3f1),theta[i-1]+(h*k3f2))

    x[i]=x[i-1]+((h/6)*(k1f1+2*(k2f1+k3f1)+k4f1))
    y[i]=y[i-1]+((h/6)*(k1f2+2*(k2f2+k3f2)+k4f2))

s=np.linspace(0,2*np.pi,n)
plt.plot(t,theta,label="theta")
plt.plot(t,phi,label="phi")
plt.xlabel('ds')
plt.ylabel('Soluciones')
plt.legend()
plt.show()

X1 = np.zeros(n)
Y1 = np.zeros(n)
Z1 = np.zeros(n)
for i in np.arange(n):
  X1[i]= a*(np.cos(phi[i])*np.sin(theta[i]))
  Y1[i]= a*(np.sin(phi[i])*np.sin(theta[i]))
  Z1[i]= b*np.cos(theta[i])
fig=plt.figure(figsize=(10,6))
ax = plt.axes(projection='3d')
ax.plot3D(X1, Y1, Z1,'blue')
d,e,g = sphere(a,b)
ax = fig.gca(projection='3d')
ax.plot_surface(d, e, g, rstride=3, cstride=3, color=(1,0.8,0,0.1))
ax.set_xlabel('Eje X')
ax.set_ylabel('Eje Y')
ax.set_zlabel('Eje Z')
plt.title('Solución numérica de la Geodésica por el método de Runge Kutta para la Elipsoide')
plt.show()